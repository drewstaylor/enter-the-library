<HTML>
<HEAD>
<META name=vsisbn content="0849371716">
<META name=vstitle content="Algorithms and Data Structures in C++">
<META name=vsauthor content="Alan Parker">
<META name=vsimprint content="CRC Press">
<META name=vspublisher content="CRC Press LLC">
<META name=vspubdate content="08/01/93">
<META name=vscategory content="Web and Software Development: Programming, Scripting, and Markup Languages: C/C++">





<TITLE>Algorithms and Data Structures in C++:Algorithms for Computer Arithmetic</TITLE>

<!-- HEADER -->

<STYLE type="text/css"> 
 <!--
 A:hover  {
 	color : Red;
 }
 -->
</STYLE>

<META NAME="ROBOTS" CONTENT="NOINDEX, NOFOLLOW">
<script>
<!--
function displayWindow(url, width, height) {
         var Win = window.open(url,"displayWindow",'width=' + width +',height=' + height + ',resizable=1,scrollbars=yes');
	if (Win) {
		Win.focus();
	}
}
//-->
</script>
<SCRIPT>
<!--
function popUp(url) {
        var Win = window.open(url,"displayWindow",'width=400,height=300,resizable=1,scrollbars=yes');
	if (Win) {
		Win.focus();
	}
}
//-->
</SCRIPT>

<script language="JavaScript1.2">
<!--
function checkForQuery(fm) {
  /* get the query value */
  var i = escape(fm.query.value);
  if (i == "") {
      alert('Please enter a search word or phrase');
      return false;
  }                  /* query is blank, dont run the .jsp file */
  else return true;  /* execute the .jsp file */
}
//-->
</script>

</HEAD>

<BODY> 

<TABLE border=0 cellspacing=0 cellpadding=0>
<tr>
<td width=75 valign=top>
<img src="../0849371716.gif" width=60 height=73 alt="Algorithms and Data Structures in C++" border="1">
</td>
<td align="left">
    <font face="arial, helvetica" size="-1" color="#336633"><b>Algorithms and Data Structures in C++</b></font>
    <br>
    <font face="arial, helvetica" size="-1"><i>by Alan Parker</i>
    <br>
    CRC Press,&nbsp;CRC Press LLC
    <br>
    <b>ISBN:</b>&nbsp;0849371716<b>&nbsp;&nbsp;&nbsp;Pub Date:</b>&nbsp;08/01/93</font>&nbsp;&nbsp;
</td>
</tr>
</table>
<P>

<!--ISBN=0849371716//-->
<!--TITLE=Algorithms and Data Structures in C++//-->
<!--AUTHOR=Alan Parker//-->
<!--PUBLISHER=CRC Press LLC//-->
<!--IMPRINT=CRC press//-->
<!--CHAPTER=4//-->
<!--PAGES=197-213//-->
<!--UNASSIGNED1//-->
<!--UNASSIGNED2//-->

<CENTER>
<TABLE BORDER>
<TR>
<TD><A HREF="187-197.html">Previous</A></TD>
<TD><A HREF="../ewtoc.html">Table of Contents</A></TD>
<TD><A HREF="213-223.html">Next</A></TD>
</TR>
</TABLE>
</CENTER>
<P><BR></P>
<P>The calculation of overflow for ripple-carry addition can be simplified by analyzing the carry-in and carry-out to the final stage of the addition. This is demonstrated in Table 4.3. An overflow occurs when 
</P>
<CENTER>
<TABLE WIDTH="100%" BORDER><CAPTION ALIGN=LEFT><B>Table 4.3</B> Carry Analysis for Overflow Detection
<TR>
<TH WIDTH="15%"><I>a<SUB><SMALL>n</I>-1</SMALL></SUB>
<TH WIDTH="15%"><I>b<SUB><SMALL>n</I>-1</SMALL></SUB>
<TH WIDTH="15%"><I>s<SUB><SMALL>n</I>-1</SMALL></SUB>
<TH WIDTH="15%"><I>c<SUB><SMALL>n</I>-1</SMALL></SUB>
<TH WIDTH="15%"><I>c<SUB><SMALL>n</I>-2</SMALL></SUB>
<TH WIDTH="25%">Overflow
<TR>
<TD ALIGN="CENTER">0
<TD ALIGN="CENTER">0
<TD ALIGN="CENTER">0
<TD ALIGN="CENTER">0
<TD ALIGN="CENTER">0
<TD ALIGN="CENTER">0
<TR>
<TD ALIGN="CENTER">0
<TD ALIGN="CENTER">0
<TD ALIGN="CENTER">1
<TD ALIGN="CENTER">0
<TD ALIGN="CENTER">1
<TD ALIGN="CENTER">1
<TR>
<TD ALIGN="CENTER">1
<TD ALIGN="CENTER">1
<TD ALIGN="CENTER">0
<TD ALIGN="CENTER">1
<TD ALIGN="CENTER">0
<TD ALIGN="CENTER">1
<TR>
<TD ALIGN="CENTER">1
<TD ALIGN="CENTER">1
<TD ALIGN="CENTER">1
<TD ALIGN="CENTER">1
<TD ALIGN="CENTER">1
<TD ALIGN="CENTER">0
</TABLE>
</CENTER>
<P ALIGN="CENTER"><IMG SRC="images/04-08d.jpg"></P>
<P>which results in the boolean expression
</P>
<P ALIGN="CENTER"><IMG SRC="images/04-09d.jpg"></P>
<H4 ALIGN="LEFT"><A NAME="Heading6"></A><FONT COLOR="#000077">4.1.3 Carry Lookahead Addition</FONT></H4>
<P>In order to improve on the performance of the ripple-carry adder the carry-in to each stage is predicted in advance rather than waiting for the carry-in to propagate from the previous stages. The carry-out of each stage can be simplified from Eq. 4.2 to
</P>
<P ALIGN="CENTER"><IMG SRC="images/04-10d.jpg"></P>
<P>or
</P>
<P ALIGN="CENTER"><IMG SRC="images/04-11d.jpg"></P>
<P>which is written as
</P>
<P ALIGN="CENTER"><IMG SRC="images/04-12d.jpg"></P>
<P>with
</P>
<P ALIGN="CENTER"><IMG SRC="images/04-13d.jpg"></P>
<P>The interpretation of Eq. 4.10 is that at stage <I>i</I> a carry may be generated by the stage, (<I>g<SUB><SMALL>i</SMALL></SUB></I> = 1) , or a carry may be propagated from a previous stage, (<I>p<SUB><SMALL>i</SMALL></SUB></I> = 1). When <I>g<SUB><SMALL>i</SMALL></SUB></I> = 1 stage <I>i</I> will always have a carry-out regardless of the carry-in. When <I>g<SUB><SMALL>i</SMALL></SUB></I> = 0 stage <I>i</I> will have a carry when the carry-in is 1 and <I>p<SUB><SMALL>i</SMALL></SUB></I> = 1, thus it is said to have propagated the carry. The time required to produce the generate, <I>g<SUB><SMALL>i</SMALL></SUB></I>, and the propagate, <I>p<SUB><SMALL>i</SMALL></SUB></I>, is 1&#916;. For the a four-bit adder as in Figure 4.3 one has</P>
<P ALIGN="CENTER"><IMG SRC="images/04-14d.jpg"></P>
<P ALIGN="CENTER"><IMG SRC="images/04-15d.jpg"></P>
<P ALIGN="CENTER"><IMG SRC="images/04-16d.jpg"></P>
<P ALIGN="CENTER"><IMG SRC="images/04-17d.jpg"></P>
<P>The interpretation of Eq. 4.14 is that a carry-out will occur from stage 3 of the 4-bit adder if it is
</P>
<DL>
<DD><B>&#149;</B>&nbsp;&nbsp;generated in stage 3
<DD><B>&#149;</B>&nbsp;&nbsp;generated in stage 2 and propagated through stage 3
<DD><B>&#149;</B>&nbsp;&nbsp;generated in stage 1 and propagated through stage 2 and stage 3
<DD><B>&#149;</B>&nbsp;&nbsp;generated in stage 0 and propagated through stage 1 and stage 2 and stage 3
</DL>
<P>The carry of the final stage, c3, can be generated in 2&#916; as shown in Figure 4.5. Similarly, the other carries can be calculated in 2&#916; or less.
</P>
<P>Once the carries are known the sum can be generated within 2&#916;. Thus for the four bit adder the sum can be generated in a total of 5&#916; with</P>
<DL>
<DD><B>&#149;</B>&nbsp;&nbsp;1&#916; to calculate the generates and propagates
<DD><B>&#149;</B>&nbsp;&nbsp;2&#916; to calculate the carries
<DD><B>&#149;</B>&nbsp;&nbsp;2&#916; to calculate the sums
<P><A NAME="Fig13"></A><A HREF="javascript:displayWindow('images/04-13.jpg',500,408)"><IMG SRC="images/04-13t.jpg"></A>
<BR><A HREF="javascript:displayWindow('images/04-13.jpg',500,408)"><FONT COLOR="#000077"><B>Figure 4.5</B></FONT></A>&nbsp;&nbsp;Delay Calculation</P>
</DL>
<P>Using ripple-carry the four bit adder would require 7&#916; to form the result. With the CLA adder the carries are thus generated by separate hardware. As is common, speed is thus achieved at the cost of additional hardware. The 4-bit CLA adder module is shown in Figure 4.3.
</P>
<P>The CLA approach can be extended to n-bits yielding the following equation for the carry bits</P>
<P ALIGN="CENTER"><IMG SRC="images/04-18d.jpg"></P>
<P>with the product term evaluating to one when the indices are inconsistent. The calculation of the carries in Eq. 4.15 can be accomplished in 2&#916; once the generates and propagates are known; however, there is a hardware requirement to be met. For each carry of the stage the implementation in 2&#916; requires that the gates have a fan-in (number of inputs, to the gate) of <I>i</I> + 1. For an n-bit CLA adder realized in this manner a gate with a fan-in of n is required. This can be seen in Figure 4.5 where for a 4-bit CLA adder the carry inputs are calculated using a 4-input NAND gate. While this is practical for a 4-bit adder it is not practical for a 64-bit adder. As a result of this an inductive approach is needed to limit the fan-in requirements of the gates to implement the circuit. The timing of the 4-bit CLA adder module is shown in Figure 4.7.</P>
<P><A NAME="Fig14"></A><A HREF="javascript:displayWindow('images/04-14.jpg',500,486)"><IMG SRC="images/04-14t.jpg"></A>
<BR><A HREF="javascript:displayWindow('images/04-14.jpg',500,486)"><FONT COLOR="#000077"><B>Figure 4.6</B></FONT></A>&nbsp;&nbsp;2&#146;s Complement 4-Bit CLA Adder Module</P>
<P>When an inductive approach is taken the module shown in Figure 4.3 will need to input a carry in to the lowest stage. As a result the basic building block will be as shown in Figure 4.3. The module will be depicted as shown in Figure 4.8. The module serves as a basic building block for a 16-bit CLA adder as shown in Figure 4. 10. For this case there are four groups of CLA-4 building blocks. The carry lookahead hardware module <I>CLM</I> (15 &#8594; 0) provides the carry input to each of the groups. This carry is predicted in an analogous fashion to before. Group 0 will generate a carry if it is generated by one of the four individual full adders within the group. One can define group generate, <I>gg<SUB><SMALL>0</SMALL></SUB></I>, as</P>
<P ALIGN="CENTER"><IMG SRC="images/04-19d.jpg"></P>
<P><A NAME="Fig15"></A><A HREF="javascript:displayWindow('images/04-15.jpg',500,371)"><IMG SRC="images/04-15t.jpg"></A>
<BR><A HREF="javascript:displayWindow('images/04-15.jpg',500,371)"><FONT COLOR="#000077"><B>Figure 4.7</B></FONT></A>&nbsp;&nbsp;4-Bit CLA Adder Module Timing</P>
<P><A NAME="Fig16"></A><A HREF="javascript:displayWindow('images/04-16.jpg',500,261)"><IMG SRC="images/04-16t.jpg"></A>
<BR><A HREF="javascript:displayWindow('images/04-16.jpg',500,261)"><FONT COLOR="#000077"><B>Figure 4.8</B></FONT></A>&nbsp;&nbsp;2&#146;s Complement 4-Bit Module Representation</P>
<P><A NAME="Fig17"></A><A HREF="javascript:displayWindow('images/04-17.jpg',500,495)"><IMG SRC="images/04-17t.jpg"></A>
<BR><A HREF="javascript:displayWindow('images/04-17.jpg',500,495)"><FONT COLOR="#000077"><B>Figure 4.9</B></FONT></A>&nbsp;&nbsp;2&#146;s Complement 4-Bit CLA Adder Module</P>
<P>and group propagate, <I>gp<SUB><SMALL>0</SMALL></SUB></I>, as</P>
<P ALIGN="CENTER"><IMG SRC="images/04-20d.jpg"></P>
<P>Similarly,
</P>
<P ALIGN="CENTER"><IMG SRC="images/04-21d.jpg"></P>
<P ALIGN="CENTER"><IMG SRC="images/04-22d.jpg"></P>
<P ALIGN="CENTER"><IMG SRC="images/04-23d.jpg"></P>
<P ALIGN="CENTER"><IMG SRC="images/04-24d.jpg"></P>
<P ALIGN="CENTER"><IMG SRC="images/04-25d.jpg"></P>
<P><A NAME="Fig18"></A><A HREF="javascript:displayWindow('images/04-18.jpg',500,421)"><IMG SRC="images/04-18t.jpg"></A>
<BR><A HREF="javascript:displayWindow('images/04-18.jpg',500,421)"><FONT COLOR="#000077"><B>Figure 4.10</B></FONT></A>&nbsp;&nbsp;16-Bit CLA Adder with Group Lookahead</P>
<P>From these equations one can derive the group carries as <I>gc<SUB><SMALL>0</SMALL></SUB></I>, the carry out of group 0,</P>
<P ALIGN="CENTER"><IMG SRC="images/04-26d.jpg"></P>
<P><I>gc</I><SUB><SMALL>1</SMALL></SUB>, the carry out of group 1,</P>
<P ALIGN="CENTER"><IMG SRC="images/04-27d.jpg"></P>
<P><I>gc</I><SUB><SMALL>2</SMALL></SUB>, the carry out of group 2,</P>
<P ALIGN="CENTER"><IMG SRC="images/04-28d.jpg"></P>
<P><I>gc</I><SUB><SMALL>3</SMALL></SUB>, the carry out of group 3,</P>
<P ALIGN="CENTER"><IMG SRC="images/04-29d.jpg"></P>
<P>The group carries become the carry-in to each of the CLA-4 modules. Each CLA-4 module can calculate the individual carries within 2&#916; after the group carries are known.
</P>
<P><B>Code List 4.5</B> CLA Addition</P>
<P><A NAME="Fig19"></A><A HREF="javascript:displayWindow('images/04-19.jpg',500,562)"><IMG SRC="images/04-19t.jpg"></A></P>
<P><A NAME="Fig20"></A><A HREF="javascript:displayWindow('images/04-20.jpg',500,807)"><IMG SRC="images/04-20t.jpg"></A></P>
<P><A NAME="Fig21"></A><A HREF="javascript:displayWindow('images/04-21.jpg',500,804)"><IMG SRC="images/04-21t.jpg"></A></P>
<P><A NAME="Fig22"></A><A HREF="javascript:displayWindow('images/04-22.jpg',500,807)"><IMG SRC="images/04-22t.jpg"></A></P>
<P><A NAME="Fig23"></A><A HREF="javascript:displayWindow('images/04-23.jpg',500,804)"><IMG SRC="images/04-23t.jpg"></A></P>
<P><A NAME="Fig24"></A><A HREF="javascript:displayWindow('images/04-24.jpg',500,802)"><IMG SRC="images/04-24t.jpg"></A></P>
<P><A NAME="Fig25"></A><A HREF="javascript:displayWindow('images/04-25.jpg',500,807)"><IMG SRC="images/04-25t.jpg"></A></P>
<P><A NAME="Fig26"></A><A HREF="javascript:displayWindow('images/04-26.jpg',500,803)"><IMG SRC="images/04-26t.jpg"></A></P>
<P><A NAME="Fig27"></A><A HREF="javascript:displayWindow('images/04-27.jpg',500,611)"><IMG SRC="images/04-27t.jpg"></A></P>
<P><B>Code List 4.6</B> Output of Program in Code List 4.5</P>
<P><A NAME="Fig28"></A><A HREF="javascript:displayWindow('images/04-28.jpg',500,119)"><IMG SRC="images/04-28t.jpg"></A></P>
<P><A NAME="Fig29"></A><A HREF="javascript:displayWindow('images/04-29.jpg',500,366)"><IMG SRC="images/04-29t.jpg"></A></P>
<H3><A NAME="Heading7"></A><FONT COLOR="#000077">4.2 A Simple Hardware Simulator in C++</FONT></H3>
<P>This section starts the implementation of a simple hardware simulator in C++. The simulator will be used to simulate the hardware required to implement the algorithms in the previous sections.
</P><P><BR></P>
<CENTER>
<TABLE BORDER>
<TR>
<TD><A HREF="187-197.html">Previous</A></TD>
<TD><A HREF="../ewtoc.html">Table of Contents</A></TD>
<TD><A HREF="213-223.html">Next</A></TD>
</TR>
</TABLE>
</CENTER>

<hr width="90%" size="1" noshade>
<div align="center">
<font face="Verdana,sans-serif" size="1">Copyright &copy; <a href="/reference/crc00001.html">CRC Press LLC</a></font>
</div>
</BODY>

